Desafío de programación: JavaScript básico

Empezar a programar en JavaScript no es tarea fácil, pero como todo, mejora con la práctica. Este curso viene a ayudarte precisamente con eso, y te trae ejercicios que podrás realizar para pulir tu forma de programar, e incluso aplicarlos al construir aplicaciones web reales en el futuro, como son la manipulación de texto, los cálculos matemáticos, la filtración de datos con funciones de arreglos y la modificación de contenidos de páginas web. ¿Empezamos a mejorar tu código en JavaScript?

https://www.linkedin.com/learning/desafio-de-programacion-javascript-basico/desafiate-con-javascript?contextUrn=urn%3Ali%3AlyndaLearningPath%3A59ba65c9498ec518b0f18061


0. INTRODUCCION

0.1  Desafíate con JavaScript

JavaScript es el lenguaje de la web y no hay duda que cada día es más importante aprender a utilizar este lenguaje. ¿Estás aprendiendo JavaScript y quieres poner en práctica lo que has aprendido? Soy Natalia Corea y vengo a presentar una serie de desafíos de JavaScript que te ayudarán a pulir sus conceptos básicos. Empezaremos escribiendo funciones para resolver problemas comunes y conforme avances por el curso encontrarás ejercicios más elaborados donde podrás aplicar lo que has aprendido sobre la manipulación del DOM y demás. Cada ejercicio es resuelto individualmente y no es necesario haber completado el ejercicio anterior para saltar al siguiente. Utilizaremos JavaScript simple para resolverlos. Por lo tanto, solo necesitas un editor de texto y el navegador para trabajar. ¡Ven y empezamos! 

1. DESAFIO DE PROGRAMACION: JAVASCRIPT BÁSICO

1.1 Número primo

Una función es un bloque de código que ejecuta una función específica y resuelve un problema. Como desarrolladores, utilizamos funciones muy a menudo para encapsular soluciones que reutilizamos constantemente a lo largo de nuestras aplicaciones. En este desafío vamos a escribir una función que determina si un número es primo o no. Si el número es primo, la función retornará un valor booleano de true. Y si el número no es primo, el valor retornado será false. Recordemos que un número primo es un número mayor a 1 que tiene únicamente dos divisores positivos distintos, el mismo y el número 1. Cabe recalcar que el número 1, por convenio, no se considera un número primo, por lo que si el valor que se pasa a la función es igual o menor a 1, la función debe retornar false. Ahora pon pausa en el video aquí, escribe tu solución y cuando hayas terminado puedes volver y ver cómo yo he resuelto este desafío. Debemos recordar que el número 1 no se considera un número primo, entonces eso es lo que primero voy a validar. Si «numero <= 1», significa que el número no es primo. Ya después de esto, el siguiente paso es validar si el número tiene algún divisor que no sea el mismo o el número 1. Para hacer esto voy a crear un bucle con un «for», voy a crear una variable llamada «i» que va a empezar con valor de «2». Este bucle va a correr mientras «i < numero» y luego irá aumentando uno por uno su valor. Ahora voy a validar si el «número» es divisible entre «i». Para esto voy a utilizar este operador para substraer el residuo de la división del número entre i. Si el residuo es igual a «0», significa que número es divisible entre i. Entonces, en este caso el número no es primo. Ya con ambas validaciones yo he logrado determinar si el número no es primo, ¿ahora qué falta? Bueno, significa que si el valor número no entra en ninguna de estas validaciones, significa que el número es primo. Entonces podemos agregar un «return» al final de la función para indicar que el valor sí es primo. Yo aquí ya tengo Chrome abierto para correr este código. Vamos a ejecutarlo, a refrescar la página y aquí vemos el resultado. Podemos ver que 2 sí es un número primo, 7 también. 10 no lo es, ya que 10 puede ser dividido entre 2 o 5. 15 no es primo porque puede ser dividido entre 5. Y 29 sí es primo.


1.2 Arreglos similares

JavaScript es un lenguaje dinámicamente tipado. Esto significa que una variable puede tomar valores de diferentes tipos conforme se ejecuta la aplicación. Los arreglos no son la excepción, ya que en JavaScript estos pueden contener elementos de diferentes tipos en cada uno de sus índices. En este desafío vamos a escribir una función, la cual determinará si dos arreglos que se pasan como parámetros son similares. Para implementar esta funcionalidad debemos recorrer cada arreglo paralelamente y comparar cada uno de sus elementos por índice de arreglo y determinar si los elementos son iguales o no. En el momento en que se encuentre que un elemento no es similar al otro, la comparación deberá detenerse y la función deberá retornar un valor de false, indicando que los arreglos no son iguales. En caso de que todos los elementos en ambos arreglos sean iguales, la función retornará un valor de true para indicar que sí son similares. Puedes pausar ahora, escribe tu solución y cuando hayas terminado vuelve aquí para ver cómo yo he solucionado este desafío. Lo primero que voy a hacer es averiguar si los arreglos tienen el mismo largo. En caso de que no sea así, voy a hacer un «return» de «false». Ahora lo que voy a hacer es comparar cada uno de los elementos de los arreglos uno por uno. Para eso voy a crear un bucle de «for» y dentro del bucle voy a crear una variable «indice» que va a empezar con valor de «0». Luego voy a crear otra variable que se llama «total», la cual va a tomar el valor de largo del «arregloA». El bucle va a correr mientras «indice <= total». Luego hacemos que el «indice» aumente su valor uno por uno. Ya dentro del for voy a agregar un «if» donde voy a validar si el valor dentro del «arregloA» según el «indice» es diferente al valor según el índice en el «arregloB». Entonces, en caso de que así suceda, voy a retornar un «false» y al final voy a hacer un «return» de «true». ¿Qué sucede aquí? Bueno, en la primera parte de la función se averigua si ambos arreglos tienen el mismo largo o el mismo número de elementos. En caso de que no sea así, entonces hago un return de false. En el for yo lo que hago es que comparo los elementos de ambos arreglos según el índice uno por uno. En caso de que no sean iguales, entonces voy a hacer un return de false. Hay que recordar que cuando uno hace un return dentro de un for, la ejecución de la función se detiene y el valor se devuelve cuando se llama a la función. Ya en caso de que los parámetros no cumplan ninguna de estas condiciones, entonces hacemos un return de true, indicando que los arreglos sí son similares. Ahora yo voy a ejecutar este código aquí en Chrome y puedes ver el resultado. Si hacemos una comparación de dos arreglos que tienen el valor 1, 2; 1, 2, 3 puedes notar que el resultado fue false, ya que ambos no tienen el mismo número de elementos. En este caso puedes notar que los arreglos son similares. Por lo tanto, yo he recibido un valor de true. En el tercer escenario tenemos dos arreglos, uno tiene números y el otro tiene caracteres. Puedes notar que yo recibo un valor de false, ya que estos son de tipos diferentes. Si yo aquí no utilizara los dobles signos de igualdad y corro este código, puedes notar que recibo un true. ¿Esto por qué sucede? Bueno, hay que recordar que JavaScript, al ser un lenguaje dinámicamente tipado, a la hora de comparar valores el lenguaje intentará hacer que los tipos de los valores comparados sean iguales. Esto significa que los números van a ser convertidos a String y se van a comparar. Este concepto se llama coerción. Para evitar que la coerción suceda, como en este escenario, debemos utilizar siempre dos o tres signos de igualdad para comparar, ya que aquí yo estoy comparando si son diferentes, entonces utilizo dos. En caso que esté comparando si son iguales, tendría que remover el signo de exclamación y poner un tercer signo de igualdad. Ya yo vuelvo a poner el código como estaba antes, lo ejecuto y puedes notar que el resultado vuelve a ser false.

1.3  El número aleatorio

A diferencia de otros objetos en JavaScript, el objeto Math no tiene constructor. El objeto Math es un objeto estático que se utiliza para ejecutar operaciones matemáticas. Todos los métodos y propiedades dentro de este objeto se pueden acceder sin tener que crear una instancia del mismo. En este desafío vamos a crear una función, la cual recibe como parámetros dos números y, utilizando el objeto Math, vamos a calcular un número aleatorio que se encuentre dentro del rango de ambos números y la función deberá retornar el valor de dicha operación. Ahora pon una pausa en en el video aquí, escribe tu solución y cuando hayas terminado puedes volver al video y ver cómo yo he implementado la solución. El objeto «Math» de JavaScript tiene un método que se llama «random», el cual genera un número aleatorio entre 0 y 1. Por ejemplo, aquí si yo hago que la función numeroAleatorio retorne el valor de Math.random, puedes notar aquí los valores que se devuelven cuando se llama a la función. Ahora yo voy a utilizar este método para generar un número aleatorio entre el númeroA y númeroB. Para eso debo tomar el valor que retorna Math.random y tengo que multiplicarlo por la diferencia entre «numeroA - numeroB». Esto para factorizar los números. Ya con esto, entonces, si yo ejecuto el código, puedes notar que los valores han cambiado y me ha generado un número diferente. Ya con este valor, entonces, yo lo único que tengo que hacer es hacer una suma del «númeroB» al final. Esto va a llevar los valores al rango entre el númeroA y el númeroB, como pueden notar aquí. Al llamar a la función con 5 y 10, obtengo un 6. Luego si llamo con -25, -22, obtuve un -23. Entre 100 y 0 obtuve un 41. Y entre -2 y 2 obtuve un 0. Lo único que quedaría hacer aquí es tal vez remover los decimales. Para eso yo puedo utilizar el método «Math.floor» y luego envolver la ecuación dentro de la función. Aquí ya puedes notar que los números han sido redondeados. Puedes notar los valores que retorna la función cada vez que yo refresco la página. 


1.4 Búsqueda de productos

Como ya sabrás, en JavaScript las variables son contenedores que guardan información. Los objetos son contenedores que pueden guardar muchas variables y estas variables pueden ser de diferentes tipos. En este desafío vamos a crear varios objetos para guardar la información de una lista de productos. Las informaciones que vamos a registrar de cada producto son ID, nombre del producto, marca y fecha de expiración. Esta lista de productos va a vivir dentro de un arreglo que va a contener todos los objetos. Vamos a escribir el código para buscar productos basados en el parámetro que pasemos en la función de búsqueda. Empezaremos intentando buscar un producto por su ID, luego intentaremos buscar un producto por su fecha de expiración. Puedes detener el video en este momento, trabajar en tu solución y luego vuelves para ver cómo yo he solucionado este desafío. Aquí primero voy a crear la lista de productos. Para eso crearé una constante que va a ser un arreglo y este arreglo va a contener objetos que tienen la información de cada uno de los productos. El primero va a tener un «id» de «1» y el nombre del producto va a ser «mantequilla», la «marca» será «DairyGold» y la «fechaExpiración» será el «20» de abril. Yo aquí estoy utilizando una fecha de expiración que es primero año, luego mes y al final día para que así se pueda convertir a un objeto JavaScript de fecha más fácilmente. Luego voy a crear otro. Simplemente voy a copiar y pegar el objeto. Este va a tener un ID de «2» y se va a llamar «leche», la marca va a ser «Avonmore» y la fecha de expiración será el «13» de abril. Le doy formato a esto. Luego voy a agregar el siguiente. He puesto una coma más de aquí. Y esto va a tener un ID de «3» y se va a llamar «jamón», la marca va a ser «Denny» y la fecha de expiración será el «18» de abril. Voy a agregar uno más, que el ID va a ser «4», el producto va a ser «pan», la marca va a ser «Brennans» y la fecha de expiración será el «29» de marzo. Y el último producto que voy a agregar va a ser «huevos», que la marca va a ser «GoldenIrish» y la fecha expiración voy a dejarla igual, el 18 de abril. Bueno, ya está lista la lista de productos. Ahora el siguiente paso es hacer la búsqueda de productos por ID. Para eso yo aquí ya tengo como el template de la función y tengo el parámetro que se pasará para buscar los productos. Entonces, yo lo que hago es un «return» de la lista de productos, pero voy a utilizar en método «filter». El método filter recibe una función que se encarga de buscar o comparar cada uno de los elementos dentro de un arreglo acorde a los criterios que yo quiera. Esta función debe retornar un valor booleano para indicar si el producto cumple con las condiciones o no para ser agregado al resultado. Por ejemplo, aquí yo voy a pasar a una función que recibe como parámetro producto, entonces lo que yo voy a hacer es que llamo a «producto.id» y lo comparo al parámetro ID que recibo en la función. Aquí podemos entonces probar la función y yo voy a pasarle un ID de «2». Voy a correr este código aquí en el navegador. Y puedes notar aquí que yo ya tengo el resultado y aquí he recibido el producto que tiene el ID 2. Entonces, la función está funcionando bien. Luego podemos hacer una búsqueda por fecha. Podemos hacer lo mismo aquí nada más copiando esta línea de código, la pegamos aquí y, en lugar de comparar ID, lo que hacemos es que comparamos por fecha de expiración, como puedes ver aquí. Si llamamos la función con console.log y pasamos por ejemplo el 18 abril, volvemos a correr el código y aquí tenemos ya los productos que coinciden con esa fecha de expiración. Podríamos hacer esta función más interesante, si así lo quisiéramos, para encontrar un producto que está dentro de un rango de fechas de expiración. Entonces, yo voy a cambiar los parámetros aquí y voy a llamar a esto «fechaA» y voy a agregar otro parámetro que se va a llamar «fechaB». Voy a asumir que ambos parámetros van a ser recibidos como String, entonces yo voy a convertir cada uno de estos String en objetos «Date» para poderlos evaluar y comparar acorde al rango de fecha. Tengo fechaA y luego copio y hago lo mismo con fechaB y así convierto cada uno en objeto fecha. Ahora el siguiente paso es buscar por rango de fecha. Yo aquí estoy agregando paréntesis a la función porque necesito agregar un par de líneas de código para poder hacer la comparación dentro del rango de fechas, entonces necesito utilizar el keyword return dentro de la función flecha. Lo primero que hago es crear un valor que es la fecha de expiración del producto, pero esta vez lo necesito como un objeto fecha de JavaScript. Ya con esto entonces yo puedo hacer un «return» donde yo diga que si la fecha de expiración del producto es menor o igual a la «fechaA» y la fecha de expiración es mayor o igual a la «fechaB», entonces que se incluya en el arreglo. Ahora entonces podemos probar esta función con esta nueva implementación. Entonces, yo voy a pasar primero un rango que va a ser desde el «30» de abril al «15» de abril. Vamos a ver qué obtenemos aquí. Y al correr la función puedes ver que ahora yo tengo tres productos, el primero vence el 20 de abril y el segundo el 18. Y también tengo otro que vence el 18. Si vemos aquí más arriba, puedes notar que la leche quedó fuera al igual como el pan, ya que no están dentro del rango que agregamos como parámetro.


1.5 La fila ordenada

Para acceder y manipular los elementos de un arreglo no solo tenemos disponible los índices, sino que también JavaScript incluye una serie de funciones que podemos utilizar para mapear y ordenar los valores en un arreglo. En este desafío vamos a crear una función, la cual va a recibir como parámetro un número, el cual se insertará en un arreglo. Los valores que reciba la función serán números positivos mayores que cero, pero su orden no es garantizado, por lo cual, el objetivo de este desafío es que todos los números dentro del arreglo deberán estar siempre ordenados de manera ascendente. Ahora pausa el video, trabaja en tu solución y luego puedes volver para ver cómo yo he solucionado este desafío. Empezando con el desafío, ya podemos ver que el ejercicio nos da cierta implementación inicial. Tenemos al arreglo donde se van a agregar los valores para ordenarlos ascendentemente y luego hay un intervalo, el cual llama a la función agregarElemento cada 4 segundos y pasa como parámetro una función la cual genera un número aleatorio entre 0 y 100. Al ejecutar esta función, puedes notar que se guarda el valor en una constante que se llama prioridad. Ahora lo que queda hacer es agregar el valor «prioridad» al «arreglo». Ahora cabe notar que estos números que vienen desde la función numeroAleatorio no vienen ordenados, entonces al agregarlo al «arreglo» debemos ordenar el arreglo. Para eso entonces voy a utilizar la función «sort», que incluye el objeto array en JavaScript. Ahora yo voy a probar este código y para eso voy a abrir Chrome, aquí ya lo tengo listo, y vamos a ejecutar el código. Puedes ver que primero recibo un 48 y luego un valor de 8, 57... Aquí hay algo que está saliendo mal, ya que el 8 se agregó después del 48. Voy a volver al código para ver qué hay que arreglar. El error sucedió porque cuando nosotros llamamos al método sort, este por defecto toma los valores y los convierte en String para compararlos. Pero, ya que yo estoy trabajando con números, esto no funciona de esta manera, por eso fue que obtuvimos un orden erróneo a la hora de ejecutar el código. Entonces, para arreglar esto debemos agregar una función de comparación dentro del método sort. Esta función va a recibir dos parámetros, que podemos llamar «a» y «b». a y b representan dos número dentro del arreglo que vamos a comparar. Y la función de comparación debe retornar un valor y este valor se va a utilizar para ordenar los elementos en el arreglo. Ya que aquí estamos trabajando con números, entonces simplemente lo que podemos hacer es substraer «b» de «a». ¿Esto qué significa? Bueno, que cuando la función de sort corra sobre los elementos dentro del arreglo, este va a tomar dos números y va a substraerlos. No hay garantía que digamos a va a ser mayor a b, entonces esto puede generar un número negativo. Pero esto no importa, ya que el número que retorne la función la va a utilizar el método sort para ordenar los elementos. Ahora ya con este cambio yo voy a volver a Chrome. Puedes notar que el código está corriendo. Lo voy a limpiar y voy a ejecutarlo otra vez. Tenemos un 93, luego un 28. Puedes notar que el 91 se agregó entre ambos números. Y ahora sí parece que la implementación está funcionando correctamente. Aquí tenemos 21, 28, 33, 73, 91, 93, 96. Y el 11 se agregó al inicio. Entonces, ahora sí el arreglo se está ordenando correctamente.


1.6 El precio promedio

En JavaScript los objetos son contenedores dinámicos de uno o más valores que se acceden a través de una key o llave. JavaScript ofrece funciones y técnicas de utilidad que podemos utilizar para recorrer y acceder a los valores dentro de un objeto. En este desafío se nos va a presentar una lista de varios objetos, los cuales contienen información sobre casas que están en venta. Cada objeto contiene un ID para identificar la casa, el número de habitaciones, tamaño en metros cuadrados, la localidad y el precio de venta. El objetivo de este desafío es determinar el precio promedio de venta por localidad. Para determinar el precio promedio de venta primero debemos sumar todos los precios de casas que se encuentran en una misma localidad y luego dividir cada valor por el número de casas en cada localidad. Para resolver este desafío no solamente tendremos que recorrer el arreglo que contiene los objetos, sino que también tendremos que crear nuestros propios objetos para almacenar los valores que iremos acumulando conforme vamos recorriendo el arreglo de objetos. Puedes detener el video en este momento, trabajar en tu solución y luego volver para ver cómo yo he implementado la solución. Para este desafío yo ya tengo disponible la lista de casas. Esta lista se encuentra en el archivo casas.js y el mismo ya está siendo cargado en el archivo HTML. Por lo tanto, la lista ya está disponible dentro de este archivo. Ahora con esto yo puedo empezar la implementación. Primero voy a crear una constante que se llama «acumulado» que va a ser un objeto. Yo voy a utilizar este objeto para hacer la agregación de los precios de las casas. Lo siguiente que voy a hacer es crear un «for» of para recorrer al arreglo de las casas. Luego para solucionar este desafío yo lo que necesito hacer es sumar los precios de las casas por localidad y también al mismo tiempo contar cuántas casas yo tengo por localidad. Entonces, para eso yo lo que voy a hacer es crear un objeto dentro del objeto acumulado cuya llave sea la localidad donde se encuentran las casas. Para hacer eso voy a empezar primero con un if y voy a decir que si «acumulado», en donde la llave o el key sea la «localidad», no se encuentre dentro del objeto, entonces voy a agregar uno vacío. Para eso llamo a «acumulado», «casa.localidad». Y esto va a tener dos propiedades. La primera va a ser «acumulado» de «Precio» cuyo valor va a ser «0» y luego un «contador» que va a tener un valor de «0» también. Entonces, ya con esto, por ejemplo, en casas que la localidad sea San José, entonces acumulado va a tener un key cuyo nombre va a ser San José y este va a obtener un objeto con las propiedades acumuladoPrecio y contador. Ya con eso entonces yo puedo empezar a hacer el agregado. Entonces, yo puedo decir «acumulado» accesando el objeto por localidad, «.acumuladoPrecio += casa.precio». Y lo mismo puedo hacer con el número de casas con el contador. Entonces, sería acumulado, la localidad, el «contador» y lo sumo en «1», ya que simplemente estoy contando uno por uno. Ya aquí entonces yo he agregado los precios de las casas por localidad, entonces yo puedo hacer un «console.log» de «acumulado» para ver qué información ha colectado. Si expandimos aquí, puedes notar que ahora yo tengo... Voy a mover esto un poquito. Yo ahora tengo, por ejemplo, Alajuela, tiene un precio acumulado que ves aquí de 350.000 y me indica que tengo tres casas, al igual por cada una de las localidades. OK. Ahora el siguiente paso es calcular el precio promedio. Entonces, yo tengo que recorrer acumulado e ir dividiendo el precio acumulado por el número de casas. Entonces, para hacer esto voy a crear una constante que se llama «localidades», la cual va a ser la lista de localidades. Y para eso yo voy a utilizar la función «Object.keys» y voy a pasar como parámetro «acumulado». Object.keys me va a devolver un arreglo que va a contener la lista de key de un objeto. Entonces, yo voy a tener un arreglo que va a decir Alajuela, Cartago, Guanacaste y demás. Ya con eso entonces yo puedo hacer otro «for» of, llamarlo «localidad» de «localidades» y aquí entonces yo puedo hacer el cálculo de los promedios. Aquí yo simplemente voy a hacer un «console.log» que va a decir que la «localidad», un espacio en blanco, y luego voy a utilizar el objeto «Math» y llamar la función «floor» para redondear el valor que va a obtener del resultado de la operación. Y luego voy a decir que «acumulado» según la «localidad», «.acumuladoPrecio», lo voy a dividir entre «acumulado» en la «localidad» por el número de casas, o sea, el «contador». Ahora puedes ver aquí cómo quedó la operación. Entonces, yo llamo Math.floor y paso aquí la división entre ambos valores. Ahora voy a guardar ese código y lo ejecuto. Y ahora puedes ver aquí el promedio de precio por cada localidad de todas las listas de casas que están aquí.


1.7  Orden alfabético

En este desafío se nos presentará un arreglo de String, el cual contiene el nombre y apellido de varias personas. El objetivo de este desafío es crear una función para ordenar los nombres alfabéticamente, ya sea por nombre o apellido. Para resolver este desafío no solo tendremos que utilizar las funciones que incluye el objeto array para acceder y ordenar los objetos de un arreglo, sino que tendremos que utilizar las funciones que incluyen el objeto String para determinar si una String debe ser colocada antes que la otra. Ahora pon pausa aquí, escribe tu solución y cuando hayas terminado puedes volver al video y ver cómo yo he resuelto este desafío. En este desafío yo ya tengo aquí disponible la lista de nombres que hay que ordenar alfabéticamente. Puedes notar que cada nombre es un String que contiene nombre y apellido. Para ordenar los nombres primero yo voy a crear una constante que se va a llamar «ordenadors». Esta constante va a tener el resultado del ordenamiento de los nombres. Ahora para ordenarlo lo que hago es que llamo al arreglo «nombres» y llamo a la función «sort». La función sort recibe como parámetro una función, la cual recibe dos parámetros «a» y «b». Estos parámetros son los valores que se van a comparar para poder ordenar el arreglo. Crea la función. Yo ahora lo que voy a hacer es extraer los «nombres» de cada String. Entonces, primero voy a crear una constante que se llama «nombreA», que va a ser el resultado de la división del String «a». Lo voy a dividir por el espacio en blanco que se encuentra entre el nombre y el apellido; «split» retorna un arreglo, entonces primero yo voy a intentar ordenar este arreglo por el primer nombre. Entonces, voy a substraer el valor del arreglo en el índice «0», ya que va a contener el nombre del momento en que se haga split del String. Lo mismo voy a hacer con b, cambio el nombre de la constante y cambio el nombre del String. Ahora lo que tengo que hacer es retornar un valor de menos uno ó uno o cero, indicando si los valores son mayores o menores. Entonces, hago un «return» en donde si «nombreA < nombreB», va a retornar un valor de «-1». Si no, voy a poner otra condición donde «nombreA > nombreB», va a retornar «1». Y si no, va a retornar un valor de «0». Voy a probar ahora a ver si esto está funcionando correctamente, entonces voy a hacer un «console.log» de «ordenadors». Voy a ejecutar el código en el navegador. Y aquí tengo un error. Ah, es que le he puesto de nombre a las constantes nombres en lugar de nombre. Lo vuelvo a ejecutar. Aquí sigo llamando nombres. Y una vez más. Aquí está. Ahora veamos a ver si el ordenamiento ha funcionado. Aquí podemos ver que primero se muestran los nombres que empiezan con A, luego con C, D, E, F, G y así sucesivamente. Si comparamos al arreglo inicial, podemos ver que primero empezaba con nombre June, pero ahora tenemos Alexander. Esto quiere decir que entonces la función de sort está funcionando correctamente. 


1.8  Carrito de compras

En JavaScript, las clases son plantillas de objetos que almacenan información y métodos que trabajan sobre dicha información. Las clases están construidas sobre prototipos. Es por esta razón que se dice que las clases en JavaScript son simplemente una manera bonita de escribir clases y herencias basados en prototipos, ya que ellas son más claras de entender. En este desafío vamos a escribir una clase en JavaScript, la cual almacenará información sobre productos de supermercado como nombre de producto, fecha de vencimiento y precio de compra. Luego vamos a crear una función que sirve como carrito de compra. Esta función deberá recibir como parámetro una lista de productos que son instancias de la clase que vamos a crear. Esta función deberá calcular el precio de compra de la lista de productos. La función también deberá evaluar que ningún producto haya pasado su fecha de vencimiento. Pon una pausa aquí, escribe tu solución y cuando hayas terminado puedes volver al video y ver cómo yo he implementado la solución. Primero voy a empezar por escribir la clase «Producto». Esta clase debe tener tres propiedades, que son «nombre», «precio» y «fechaVencimiento». Ahora para actualizar las propiedades de la clase tenemos dos opciones, podemos utilizar modificadores o un constructor. Yo voy a ir con la opción del «constructor», el cual va a recibir tres parámetros para actualizar cada una de las propiedades. Ahora aquí lo que hago es que llamo con el keyword «this» cada propiedad y le asigno el valor. Hago «this._precio», le asigno el «precio» y luego hago «this._fechaVencimiento», que es igual a la fecha de vencimiento. Ahora lo que sigue es escribir la función de carrito de compra. Esta va a recibir un array que contiene instancias de la clase producto, entonces la voy a llamar «productos». Los requerimientos nos dice que la función de retornar el total de la suma de los productos dentro del arreglo, excluyendo los que ya están expirados. Entonces, primero yo debo eliminar los productos que ya están expirados. Para eso voy a crear una constante que se llama «hoy» que va a ser una instancia del objeto fecha. Luego voy a crear otra constante que se llama «productosValidos» que va a almacenar los productos filtrados. Para filtrar los productos lo que hago es que llamo al objeto array y llamo a la función «filter». En filter paso una función como parámetro que va a recibir un parámetro que se va a llamar «producto». Este indica el producto que está siendo evaluado en la ejecución de la función. Ahora lo que hago es que llamo al parámetro «producto» y valido que la fecha de vencimiento sea mayor al valor que contiene «hoy» de esta manera. Ahora, aquí hay algo que no va a funcionar porque aquí yo dentro de la clase lo que estoy asignando es el valor directamente. Ahora, ¿qué pasa si esto es un String? Bueno, yo voy a asumir que lo que se recibe como parámetro es un String y se lo estoy asignando directamente a la propiedad, pero a la hora de validarlo con el objeto fecha no va a funcionar. Entonces, lo que voy a hacer aquí es convertir este valor en un objeto fecha de esta manera. Ahora sí, siendo fechaVencimiento y hoy ambos objetos fecha, entonces esta condición sí debería funcionar. Ya con esto yo lo que hago es que hago un «return» de los «productosValidos» en donde yo llamo a la función «reduce». La función reduce como parámetro otra función, la cual tiene dos parámetros. La primera es un «acumulador» y la segunda es el «producto» o la instancia del producto que se está evaluando en ese momento. Reduce lo que hace es que convierte un arreglo a un valor en específico, que ese valor se almacena en acumulador. Entonces, aquí lo que hago es que a «acumulador» le sumo el precio del producto. Ahora como segundo parámetro dentro de la función reduce paso el valor de «0» para indicar que el acumulador va a empezar en 0. Entonces, ya con esto esta función va a devolver un número que es la suma de todos los precios de las instancias dentro del producto. Ahora lo que queda hacer es simplemente probar la función. Vamos a ver cómo nos va. Entonces, voy a crear una constante del resultado que va a almacenar el resultado al llamar la función. Aquí yo voy a crear las nuevas instancias de producto. Primera va a tener un nombre de «leche», que va a tener un precio de «4» y la fecha de vencimiento va a ser el «15» de marzo. Luego voy a crear otro más. Este se va a llamar «pan», tiene un precio de «2» y se va a vencer el «14» de marzo. 


1.9  Una calculadora

Los elementos en una página web son representados por el Document Object Model o DOM, que es una interfaz de programación para documentos web. JavaScript nos permite crear aplicaciones web interactivas, ya que este incluye funciones que nos permiten acceder y manipular los objetos que se encuentran en el DOM. Este desafío nos presenta un formulario en HTML que incluye un campo de texto de tipo número y cuatro botones que ejecutan cada uno una operación matemática diferente de suma, resta, multiplicación y división. El objetivo de este desafío es crear una funcionalidad para convertir este formulario en una calculadora. La calculadora funcionará como una calculadora normal donde el resultado de la operación anterior será el valor de inicio de la operación siguiente y el resultado deberá mostrarse en pantalla al usuario. Ahora pausa el video, trabaja en tu solución y luego puedes volver para ver cómo yo he solucionado este desafío. Este desafío ya incluye una página HTML, la cual contiene todos los elementos necesarios para construir la calculadora como puedes ver aquí y cada elemento tiene su correspondiente constante como ves aquí, que ya tienen los addEventListener del evento click que ejecuta la función ejecutarOperacion cuando se hace clic. Ahora yo voy a empezar con la implementación y lo primero que voy a hacer es crear un objeto que se llama «operación», el cual va a tener todos los valores necesarios para ejecutar una operación matemática. Primero voy a tener «valor1», que va a empezar con valor de nulo. Luego tenemos el «valor2», que también es nulo. Y el operador, nulo también. Ahora voy a crear una variable que se llama «tempOperador» que van a empezar como nulo también. Ahora lo que voy a hacer es aquí agregar las diferentes condiciones para ejecutar la funcionalidad de la calculadora. Hay que recordar que esta función se llama cada vez que se haga clic en un botón. Entonces, yo lo primero que voy a validar es si la «operación» no tiene un valor de 1. En caso de que así sea, entonces voy a guardar el valor de 1 y también voy a guardar el «operador», que este está contenido en el «evento.target.innerText». Y luego voy a mostrar al usuario los valores que eligió al llamar la función mostrarValores que ves aquí. Y a este le voy a pasar una String, la cual contiene la «operacion.valor1» más «operacion.valor2». Y luego hacemos un «return» de la función. El return es para que la ejecución de la función se detenga luego de que esto sea ejecutado. Este if se va ejecutar la primera vez que el usuario haga clic en un botón de los que ves aquí. Ahora voy a agregar otro «if» que lo que va a hacer es validar si la «operación» no tiene «operador». Entonces, simplemente voy a llamar estas tres líneas de código aquí. Este if lo vamos a necesitar cuando el usuario esté haciendo operaciones ligadas una detrás de otra, o sea, cuando el usuario haga una operación y luego siga apretando botones de más, menos, división o multiplicación uno seguido del otro con valores en el medio. Entonces, tenemos que ir actualizando qué operador el usuario va eligiendo. Para eso entonces necesitamos este if. Ya con esto entonces yo voy a llamar «operación» y indicar que el «valor2» es igual al «valor», o sea, que si este if y este if no se ejecutan, entonces esta línea es la que se va a ejecutar. Y voy a agregar otro «if» aquí y voy a decir que si el «evento.target.innerText» no es el símbolo de igual, entonces voy a guardar el valor en el «tempOperador». Esto es para tener disponible qué operador eligió el usuario para la siguiente operación. Y aquí al final voy a llamar «calcularResultado». Ahora voy a ir a la función calcularResultado. En calcularResultado lo que voy a hacer es actualizar estos valores y voy a llamar el objeto «operación» en cada uno de estas propiedades de esta manera. Puedes notar que la función ya contiene una variable total y esta se actualiza según el operador que contenga el objeto operacion. Ya que tenemos ya aquí el total, entonces yo puedo mostrarle el usuario, el resultado de la operación. Entonces, voy a pasar «total» y luego voy a pasar también el «tempOperador» en caso de que no sea nulo. Si no, entonces, una cadena vacía. ¿Esto por qué? Bueno, recordamos que el tempOperador contiene el operador de la siguiente operación, que es basado en el total con el resultado de la operación anterior. Entonces, aquí de una vez se la mostramos al usuario al llamar el valor de esta manera. Ya con eso entonces yo debo reiniciar las propiedades del objeto «operación». En «valor1» agrego el «total», ya que el total se va a utilizar para la siguiente operación si el usuario así lo desea. Luego asigno un «null» al «valor2» y también hago lo mismo con el «operador». De hecho, aquí yo tengo que pasar el «tempOperador» en caso de que no sea null. Y si no, entonces, simplemente se va a reiniciar con el operador. El «tempOperador» también lo asigno a «null» para reiniciarlo en caso de que tenga un valor. Ya con esta funcionalidad voy a probar la calculadora a ver cómo me va. Voy a poner un valor de «10» y digo que más. OK. Aquí tenemos un nulo, entonces algo no está bien. Puedes notar aquí que yo cometí un error, en lugar de llamar operador llamé valor2, y voy a corregirlo aquí también. Voy a refrescar la página, voy a intentarlo otra vez. Ahora sí funciona. Agrego un valor de 2 y ahora puedes notar que el total se calculó correctamente. Ahora si yo aprieto el botón de dividir y digo que lo divido entre «2» y nuevamente hago clic en el igual, puedes notar que el resultado funcionó. El tercer escenario es cuando las operaciones son ligadas. Entonces, voy a tomar esto, agrego un símbolo de más y agrego otro valor y luego hago clic en un botón de operación matemática, voy a hacer un menos, puedes notar que el total se calculó. Y voy a agregar otro valor aquí y hago clic en otro botón y puedes notar que el resultado se calculó correctamente. 


1.10  El piso es lava

JavaScript incluye varios eventos que nos permiten rastrear la actividad del puntero del mouse en la página web y cómo este interactúa con otros elementos en el DOM. En este desafío se nos presentará una página web, la cual contiene una serie de elementos que están colocados aleatoriamente a lo largo de la pantalla. El objetivo de este desafío es indicar al usuario si el puntero se está quemando o no. Cuando el puntero esté colocado en alguno de los elementos en la página, se mostrará un mensaje al usuario indicando que el puntero está a salvo. Pero si el puntero está colocado en el fondo de la pantalla, esto significa que se está quemando. El mensaje deberá ser mostrado al usuario refrescado cada vez que el puntero se mueva por la pantalla. Pon pausa aquí, trabaja en tu solución, luego puedes volver y ver cómo yo he resuelto este desafío. Antes de empezar a resolver este desafío vamos a ver qué es lo que ya ofrece el ejercicio. Refrescando la página, puedo notar que hay elementos que se generan y se posicionan aleatoriamente por la página y luego hay un área aquí arriba la cual tiene de objetivo mostrar el resultado. El código que genera todos estos elementos es esta función que puedes encontrar aquí. Y luego aquí hay una constante que hace referencia al span que vemos aquí arriba. Ya con esto entonces voy a empezar a resolver el desafío. Para esto voy a llamar al objeto «document» y voy a agregarle un «addEventListener». Este addEventListener es el de «mousemove», ya que este se ejecuta cada vez que el mouse mueva por la pantalla. Y luego seguido de esto voy a pasar como parámetro una función, la cual se va a ejecutar cada vez que el mouse se mueva. Esta función recibe como parámetro un objeto que contiene la información del evento de mousemove. Luego yo lo que quiero aquí es detectar que si el mouse está tocando algún elemento de estos que se han generado. Para eso entonces voy a capturar las coordenadas X y Y del objeto «evento». Para esto llamo a la propiedad «clientX» que se encuentra dentro del objeto. Y hago lo mismo con la coordenada Y. Ya con esta información entonces yo puedo utilizar la función «document.elementFromPoint». Esta función lo que hace es que retorna el elemento HTML acorde a las coordenadas que pasemos como parámetro. Yo puedo guardar ese resultado en una constante y esta la voy a llamar «el». Luego ya con esta información yo puedo validar qué elemento me retornó la función elementFromPoint. Entonces, yo voy a validarlo por el «tagName». Entonces, voy a decir que si el elemento HTML tiene un tagName, que es igual a «BODY» o si el «tagName» del elemento se llama «HTML», entonces el «resultado» deberá mostrar que «El puntero se está quemando». Si no, «resultado» debe mostrar que «El puntero está a salvo». Ahora voy a refrescar la página para ver si eso funciona. Aquí puedes ver como se actualiza la información en el área de resultados cada vez que yo muevo el puntero encima de alguno de los tips, entonces esto indica que el puntero está a salvo. Y si toca el fondo de la página, entonces es que se está quemando. Aquí puedes ver que yo estoy validando dos tagName, uno es el BODY y el otro es el HTML. Ya que yo puse el evento de mouse encima del document, entonces yo estoy accesando directamente al tag de HTML de la página y al BODY. Entonces, en cualquier caso, cuando se toca el fondo, yo voy a obtener como resultado alguno de estos dos. Cualquier cosa que no sea esto, entonces significa que el puntero está a salvo. 


1.11 El juego del bingo

Las matrices son estructuras de datos compuestas de filas y columnas que se utilizan en muchos tipos de cálculos matemáticos y representación de datos. En JavaScript, para poder crear una matriz debemos tener un arreglo el cual cada uno de sus elementos será otro arreglo. Cada arreglo hijo representa una fila de datos y los elementos en cada arreglo serán las columnas de la matriz. En este desafío se nos presentará una matriz cuadrada. Esto significa que el número de filas y de columnas es el mismo, lo que representa el tablero de un bingo. El objetivo del desafío es comprobar que el usuario ha ganado el bingo al determinar si la matriz tiene una fila o una columna donde todos los elementos son iguales. En caso de que el usuario haya ganado el bingo, la aplicación deberá imprimir un mensaje para indicarle al usuario que ha ganado un premio. En caso contrario, también se le mostrará un mensaje a la consola. Ahora pausa el video, trabaja en tu solución y luego puedes volver para ver cómo yo he resuelto este desafío. Este desafío ya incluye una función que genera la matriz cuadrada. La matriz que se genera tiene un tamaño de cuatro columnas por cuatro filas y contiene números entre 0 y 1. Ahora ya con esto entonces yo puedo utilizar la constante matriz para validar si el usuario ha ganado el bingo. Lo primero que voy a hacer es crear una «funcion» que se va a llamar «arregloValido», la cual va a recibir un arreglo que contiene «valores». Esta función va a hacer un «return» de «valores» llamando a la función «every». Esta función recibe como parámetro una función, la cual valida que todos los valores dentro del arreglo cumplan una condición. Entonces, yo voy a validar que todos los valores dentro del arreglo que recibe como parámetro sean iguales. Para eso lo que hago es que comparo los valores dentro del arreglo con el primer valor dentro del mismo arreglo y en el momento en que este valor sea falso, entonces every va a retornar false. Pero si todos los valores dentro del arreglo cumplen la condición, entonces la función va a retornar true. Yo voy a utilizar esta función para validar las filas y las columnas de la matriz. Ahora ya con esto entonces yo puedo empezar a validar la matriz y para esto voy a empezar por las filas. Entonces, voy a crear un «for» en donde «fila» es igual a «0» y el valor «fila» es menor al tamaño de la matriz y luego voy aumentando el valor uno por uno. Aquí voy a agregar una condición que dice que si «arreglo» es válido y paso como parámetro la fila de la matriz. Para eso llamo la constante «matriz» y paso la «fila» que estamos seleccionando en este momento. En caso que todos los valores de la fila sean iguales, entonces voy a guardar un resultado en una variable que voy a llamar «resultado», la cual es una String, y voy a guardar la fila que contiene todos los valores que son iguales para saber cuál es la fila ganadora. Para esto guardo el resultado como un String y paso como parámetro el número de fila. Este for lo que irá es ir fila por fila validando que todos los valores en cada fila sean iguales y en el momento que encuentre una que es igual, entonces la va a guardar y va a detenerse también la ejecución del for. Puedes notar aquí que agregué un «break» para este propósito. Ahora, en caso de que no hay una fila que contenga todos los valores iguales, entonces tenemos que validar las columnas. Entonces, yo voy a decir que si «resultado» es igual a una cadena vacía, entonces voy a validar las columnas. Para esto voy a copiar este mismo código, ya que es muy similar, pero en lugar de fila voy a llamarlo «columna». Igual, columna empieza con un valor de 0, es menor al tamaño del tablero y aumenta uno por uno. Aquí la diferencia es que la columna tenemos que generarla, ya que los valores de la columna viven en arreglos diferentes, como puedes ver aquí. Entonces, para yo poder acceder a las columnas voy a utilizar la función map de la matriz. La función map lo que hace es que convierten los elementos de un arreglo en otro valor. Entonces, por ejemplo, yo aquí lo que hago es que recorro todas las filas y lo que hago es que entonces retorno el valor de la «fila» según la «columna». Por ejemplo, ya que empezamos columna con valor de 0, entonces lo que va a hacer es tomar todos los valores que se encuentran en el índice 0 de todas las filas y se guardan en el arreglo que se llama columnaEl. Ahora ya con esto generado, las columnas, entonces ahora lo que queda es simplemente validar si hay alguna columna que tenga todos los valores iguales. Para eso paso la columna como parámetro a la función arregloValido. En caso de que haya una «columna» que sea igual, entonces voy a guardarla en el resultado. OK. Ahora con esto lo que hago es simplemente un «console.log» del «resultado». Y veamos qué nos muestra la consola del navegador cuando yo refresco la página. Ahora puedes ver aquí que la consola indica que la fila 1 es la que contiene todos los elementos que son iguales, ya que nos estamos manejando por índice, entonces la fila 1 es esta que puedes ver aquí. Podemos refrescar esto nuevamente. Y, bueno, parece que la fila uno nuevamente es la ganadora. Vamos a refrescarlo otra vez. Ahora me dice que es la fila 2 y ahora aquí me dice que es la columna 2. Cero, uno, dos y, como puedes ver, la columna toda contiene ceros.


1.12 Buscando el elemento perdido

En programación, la recursión es el método de resolver un problema al resolver instancias más pequeñas del mismo problema. La recursión generalmente se implementa al crear una función que se llama a sí misma y la secuencia se detiene en el momento en que el resultado se encuentre o se haya llegado al límite de las posibilidades. Para este desafío se nos presentará una página web que contiene varios elementos HTML los cuales cada uno tiene elementos anidados. El objetivo de este desafío es hacer una función y utilizar la técnica de recursión para buscar un elemento en específico dentro del DOM. Tú podrás escoger el elemento que la función deberá buscar, lo importante de este desafío es la aplicación de la recursión para validar cada uno de los elementos de la página y sus elementos anidados y así encontrar el elemento buscado. Puedes poner una pausa aquí, trabajar en la solución y luego volver y ver cómo yo he resuelto este desafío. Como puedes ver aquí, este desafío ya incluye un HTML el cual tiene muchos div anidados unos dentro de los otros y algunos tienen algunos elementos de tipo texto. En el código lo que yo voy a hacer es validar si el Elemento9 existe dentro de los div. Para esto primero voy a crear una función que se llama «buscarElemento» y esta va a recibir un parámetro que se llama «root». Lo primero que voy a hacer es validar si «root» contiene el elemento que yo estoy buscando. Para esto primero lo que voy a hacer es validar si la propiedad «innerHTML» es igual al «elemento» que estoy buscando o si la propiedad «innerText» del root es igual al «elemento». En caso de que sea así, entonces voy a poner «encontrado» como «true» y voy a hacer un «return» de la función para detener la ejecución en caso de que la condición se cumpla. Luego aquí yo estoy trabajando con una función recursiva, esto significa que esta función se va a llamar a sí misma. Y todas las funciones recursivas deben contener una condición que detenga la llamada recursiva. Aquí entonces yo lo que voy a hacer es agregar una condición para detener la recursividad. Entonces, lo que voy a validar es que si el «root» tiene la propiedad «children» pero esta propiedad está vacía, o sea, que si el «length» es igual a «0», entonces la ejecución de la función se va a detener. Ya con esto entonces yo lo que voy a hacer es llamar la función recursivamente en cada uno de los hijos nodos del root. Para esto lo que hago es que creo un «for» of donde crea una condición «hijo» dentro del «root.children» y llamo a la función recursivamente en cada uno los hijos. Ahora voy a probar la función y para esto lo que hago es que llamo a la función «buscarElemento» y paso el «body» de la página. Y al final voy a hacer un «console.log» del resultado para ver si el elemento se encontró o no. Entonces, voy a refrescar la página y aquí puedes ver que la función me ha tirado un true. Si yo paso un elemento que no exista, por ejemplo si paso un valor de «XXX», me dirá que el valor no se encuentra. Y con este código entonces yo he resuelto el desafío.


1.13 El scroll infinito

Es muy común en algunos sitios web al hacer scroll en la página que más elementos se carguen. Esto se llama scroll infinito, ya que los elementos se van agregando a la página conforme el usuario va moviendo el scroll al fondo de la misma. En este desafío vamos a crear un scroll infinito donde vamos a utilizar el evento scroll de la página para así poder detectar cuando los usuarios se hayan movido al extremo del contenido y, cuando esto suceda, vamos a agregar más elementos para así simular la carga dinámicamente. Puedes detener el video en este momento, trabajar en tu desafío y luego volver para ver cómo yo he implementado la solución. Este desafío ya incluye una página HTML la cual incluye ya una lista no ordenada, como puedes ver aquí. Cada li se muestra como un cuadrado con color rojo, como puedes ver en la página. Ahora aquí en el archivo JavaScript yo voy a implementar el scroll infinito. Lo primero que voy a hacer es llamar la propiedad «document» y agregarle un «listener» de «scroll» y luego voy a pasar una función la cual se va a ejecutar cada vez que el usuario haga scroll en la página. Ahora aquí lo que debo hacer es capturar varias propiedades. La primera es la altura del documento. Esta propiedad la obtenemos llamando «document.documentElement.scrollHeight». Luego voy a capturar otra propiedad que se llama altura de la ventana. Y este valor yo lo obtengo al llamar «document.documentElement.clientHeight». Y ahora necesito una tercera que se va a llamar «scrollTop», que lo obtengo al llamar «document.documentElement.scrollTop» Explicando brevemente, alturaDocumento o scrollHeight lo que hace es que me retorna el tamaño de este contenedor que ves aquí sin tomar en cuenta el scroll. Luego la altura de la ventana contiene el tamaño o el alto del navegador o el área del browser. Y scrollTop lo que retorna es en pixeles el offset o, digamos, la diferencia entre la altura del documento y la altura de la ventana, la parte que no vemos o que está escondida a la hora de hacer scroll. Ahora con esto yo voy a poder validar si el usuario ha hecho scroll al final de la página, ya sea arriba o abajo. Para esto voy a llamar un «if» y voy a sumar «scrollTop» y altura de la ventana y en caso que sea igual a la altura del documento, esto indica que el usuario ha hecho scroll al final de la página. Entonces, ya con esta información yo voy a agregar más elementos a la misma. Entonces, para esto llamo el «contenedor», que contiene todos los elementos li y voy a crear uno nuevo. OK. Ahora voy a refrescar la página y vamos a ver si este código funciona correctamente. Si yo me voy al final de la misma, puedes ver que se siguen agregando elementos. Podemos verlo aquí también utilizando las herramientas del desarrollador del navegador. Puedes notar como se van agregando elementos al final. Ahora podemos hacer lo mismo si el usuario está haciendo scroll y llega al final de la página pero cuando hace scroll hacia arriba. Para eso validamos si la propiedad «scrollTop» es igual a «0», o sea, que no hay diferencia entre la posición del contenedor y el scroll, ya que está aquí en 0. Entonces, significa que el usuario está al inicio de la página. Entonces, para esto voy a llamar... De hecho, voy a copiar esta línea y la voy a pegar aquí. Pero, a diferencia de lo que tenemos aquí appendChild, yo voy a llamar la función «prepend». AppendChild lo que hace es que agrega un elemento al final de la fila y prepend la agrega al inicio. OK. Ahora si yo hago scroll al final, los elementos se agregan. Y si yo hago scroll hacia arriba, puedes notar que el elemento se agrega, pero el efecto no es igual que cuando hacemos scroll hacia abajo y esto es mucho por el comportamiento del navegador, ya que este tiende a empujar el contenido hacia abajo. Ya que aquí estamos en posición cero, entonces, por así decirlo, los elementos se van hacia abajo. Es por esta razón que el scroll hacia arriba no es común. A pesar de que es posible, no es común, pero sí el scroll infinito hacia abajo es muy común en páginas web.


1.14 El marcador de texto

En este desafío vamos a simular un editor de texto donde se le presentará al usuario un texto en pantalla y un input donde el usuario podrá escribir el texto que quiera marcar en negrita. Para completar este desafío, no solo tendremos que utilizar los eventos de input para detectar cuando los usuarios han escrito el texto que quieran marcar, sino que también deberemos utilizar funciones para buscar el texto en el párrafo y, utilizando métodos en JavaScript, seleccionaremos el texto deseado y actualizaremos la vista en pantalla. Puedes poner una pausa aquí, trabajar en la solución y luego podrás volver y ver cómo yo he resuelto este desafío. Como puedes ver aquí, este desafío ya incluye una página HTML, la cual tiene un texto, un campo de texto y un botón de buscar. Y ya las constantes para acceder estos elementos han sido creadas. Entonces, yo voy a empezar a trabajar en la funcionalidad para editar el texto. Para eso agrego un «listener» al botón y dentro de la función lo que voy a hacer primeramente es capturar el texto que se encuentra en la pantalla. Repito, el texto que se encuentra la página. Para esto voy a crear una variable que se llama «parrafos» que va a contener el «innerHTML» del elemento «texto». Y ahora lo que voy a hacer es capturar el valor que el usuario agregue en el campo de texto. Para ese entonces llamo a la propiedad «value» del «input» y lo guardo en una constante. Entonces, voy a validar que si «valor» es diferente a una cadena vacía de texto, voy a ejecutar la función. Y para esto entonces voy a decir que «parrafos» es igual a «parrafos» y voy a llamar la función «replace», que pertenece a los String, y voy a pasar como parámetro primero el valor para que lo busque y luego el reemplazo para marcar el valor en negrita. Esto significa que voy a pasar una cadena texto que contiene las etiquetas de "bold" y voy a pasar el valor aquí para que se actualice en pantalla. Entonces, significa que todas las coincidencias de valor deberán reemplazarse con este String. Y luego de esto voy a llamar al texto nuevamente y voy a actualizar la propiedad «innerHTML» con los cambios que tenga «parrafos». Ahora voy a probar el código y voy a tomar una palabra de aquí, por ejemplo esta, y voy a buscar. Voy a hacer otra prueba, por ejemplo esta, puedes ver que hay varias coincidencias y voy a ver qué sucede. OK. He encontrado el problema aquí, que esta propiedad se puso mal, voy a volverlo a intentar y ahora voy a poner la palabra ahí, Buscar, y ves que ahora sí está funcionando. Ahora notarás aquí que hay varias coincidencias de la misma palabra, pero estas no están siendo marcadas en negrita. Esto es porque la función replace va a trabajar solamente con la primera coincidencia que encuentre en el texto y las demás se van a ignorar. Para arreglar esto tenemos que utilizar una expresión regular. Entonces, yo voy a crear una expresión regular la cual va a recibir de parámetro el valor y luego voy a utilizar la bandera «g». Esto indica que la expresión regular va a buscar todas las coincidencias del valor dentro del texto. Y ahora yo paso la expresión regular a la función replace. Quito valor, pongo la expresión regular y ahora voy a probar esto nuevamente. Voy a tomar otra palabra, pues la misma que utilicé anteriormente, y al hacer en Buscar ahora puedes notar que todas las coincidencias han sido marcadas. Voy a probar esto nuevamente. Por ejemplo, Null, que parece que es muy común en el texto, como puedes ver aquí. Entonces, voy a ponerlo aquí, voy a hacer Buscar y ahora ves que el código ha funcionado correctamente.


1.15 Validación de número de teléfono

Una expresión regular es una serie de caracteres que podemos utilizar para determinar el patrón de un String. Las expresiones regulares son sumamente utilizadas para validar los valores que un usuario agrega en un formulario. En este desafío vamos a escribir una expresión regular que deberá validar el formato de un número de teléfono. Le presentaremos al usuario un campo de texto donde él o ella podrá escribir el número de teléfono y luego la aplicación deberá mostrar si el número de teléfono es válido o no. El formato que utilizaremos será el de cuatro números seguido por un guion, dos números más seguido por un guion y finalmente dos números más. Puedes poner pausa en el video ahora, trabajar en tu solución y cuando termines puedes volver y ver cómo yo creé esta validación. Este desafío ya contiene una página HTML, la cual contiene un campo de texto, un botón de buscar y un área de texto que se encuentra aquí que se va a utilizar para mostrar el resultado. También incluye un listener al botón click del botón Buscar para ejecutar la validación. Ahora lo que yo voy a hacer es crear la expresión regular para validar que el valor que se ponga aquí siga el formato de número de teléfono que andamos buscando. Para esto entonces voy a crear una constante, la cual para recibir la expresión regular, y voy a pasar también la bandera global indicando que la búsqueda se va a ejecutar en todo el String. Ahora voy a empezar a trabajar en la expresión regular. Como para recordar, las expresiones regulares utilizan símbolos para representar los patrones de un String. Entonces, yo voy a validar primero que haya cuatro números al inicio. Para eso voy a agregar paréntesis cuadrados, los cuales indican que el valor que andamos buscando o el primer carácter pertenece a un grupo de elementos. Entonces, yo voy a pasar que este debe ser entre «0» o «9». Ahora necesitamos validar que sean cuatro los números aquí entre este grupo. Entonces, yo voy a utilizar paréntesis y voy a pasar el número «4». Ahora yo tengo que validar que luego siga un guion. Para esto nada más simplemente tengo que poner el carácter aquí y luego tengo que repetir lo mismo que hice con estos números para validar que sean dos solamente. Entonces, puedo copiar esto que está aquí y ponerlo y cambiar el valor de «2». Y luego simplemente tengo que agregar el siguiente guion y pegar el mismo valor que tenía antes pero cambiando el último número a un «2». OK. Ya tenemos la expresión regular, ahora lo que queda es validar que el valor cumpla con la expresión regular. Para eso entonces llamamos a un «if» y utilizamos la función «test» de la expresión regular. La función test retorna un booleano indicando si el valor cumple con la expresión regular o no. En caso de que así sea, entonces vamos a decir que «resultado.innerText» es igual a «Teléfono es válido». En caso de que no lo cumpla, entonces vamos a mostrar un mensaje diciendo que no es válido. Ahora voy a probar la funcionalidad. Si agrego un número random, me dice que no es válido. Ahora voy a probar a ver si funciona. Entonces, digo 1, 2, 3, 4, guion, dos números, guion, dos números, y ahora me dice que es válido.


